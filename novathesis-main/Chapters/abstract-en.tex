%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% abstract-en.tex
%% NOVA thesis document file
%%
%% Abstract in English([^%]*)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE abstract-en.tex}%

Model-driven development, particularly using formalisms like Input-Output Place-Transition (IOPT) Petri nets, offers a robust approach for designing complex embedded controllers. The IOPT-Tools framework supports this by automating the generation of controller logic, but a significant gap exists in its ability to automatically generate the communication infrastructure required for distributed systems. This necessitates a manual, time-consuming, and error-prone process for implementing inter-controller communication links.

This dissertation addresses this gap by presenting the design, implementation, and validation of a web-based Application Programming Interface (API) for the automated generation of communication modules. The tool dynamically produces C++ code for three distinct protocols, I2C, UART, and TCP/MQTT, designed for direct integration into the IOPT-Tools workflow.

The utility and performance of the generated code were validated through a comprehensive case study of a three-conveyor distributed system managed by four controllers.. An empirical analysis yielded quantitative performance metrics, demonstrating the significant trade-offs between protocols: hardware-level protocols such I²C (185 µs latency, negligible memory overhead) offered superior real-time performance, whereas the network-level TCP/MQTT (45 ms latency, >26 kB overhead) provided greater functional flexibility. The dynamic behavior of the implemented system was also verified against the original IOPT models using simulator-generated timing diagrams.

The results confirm that the developed tool successfully accelerates distributed system development, reduces implementation errors, and empowers designers with the empirical data needed to make informed, data-driven decisions when balancing performance requirements against the resource constraints of embedded systems.

