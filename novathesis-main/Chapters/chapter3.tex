%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter2.tex
%% NOVA thesis document file
%%
%% Chapter with the template manual
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter2.tex}%

\chapter{System Design and Implementation}
\label{cha:chap_3}


As discussed in Section~\ref{subsec:communication_gap}, the IOPT-Tools environment provides robust support for modeling, verifying, and generating code for individual controller sub-models specified with \gls{iopt} Petri nets \cite{iopttools, barros2004, RefiningIOPT}. However, a significant limitation arises in distributed control systems, particularly under the \gls{gals} paradigm, where decomposed sub-models require intercommunication \cite{galsactd, Barrosadd}. Current automatic code generation within IOPT-Tools focuses primarily on the internal logic of each sub-model, leaving the implementation of communication links to be carried out manually. This process is time-consuming, error-prone and poses substantial challenges for debugging and validation.  

The objective of this dissertation is to address this gap by proposing an automated code generation tool capable of analyzing decomposed \gls{iopt} sub-models obtained through the decomposition of GALS systems in IOPT-Tools and automatically producing the necessary communication infrastructure code. In doing so, the tool streamlines the development of distributed control systems and ensures efficient and reliable data exchange pathways.  

This chapter presents the design, implementation, and validation of the proposed tool. It begins with an overview of the system architecture, developed as a web-based Application Programming Interface (API) integrated within the IOPT-Tools ecosystem. The chapter then details the transformation pipeline, from model inputs to generated code outputs, and provides a formal specification of the API endpoints and parameters. Subsequently, the generated C++ code is analyzed with respect to three communication protocols: I²C, UART, and TCP/MQTT. Finally, the chapter outlines the validation methodology used to assess both the correctness and reliability of the tool’s output.  


% ===================================================================
% Section 3.1
% ===================================================================

\section{Key Design Decisions}
\label{sec:design_decisions}

The tool is implemented as a server-side web Application Programming Interface (API). This architecture decouples the code generation logic from the end-user's local environment, providing a platform-independent and highly accessible solution. The core of the system is a single PHP script, \texttt{gals.php}(mudar), which resides on a web server and is responsible for processing all incoming requests.



\begin{enumerate}
    \item \textbf{User Request:} The user constructs a Hypertext Transfer Protocol (HTTP) GET request that contains a set of URL parameters. These parameters specify the desired communication protocol and its configuration, as detailed in Section ~\ref{sec:api_spec}.
    \item \textbf{Server-Side Processing:} The web server receives the request and forwards it to the \texttt{gals.php}(mudar) script. The script parses and validates the input parameters, selects the appropriate code template based on the chosen protocol, and dynamically populates it with the user-provided values.
    \item \textbf{Code Generation:} The script generates the complete C++ source code tailored to the user's specifications. In the event of invalid or missing parameters, the script generates an appropriate HTTP 400 error response.
    \item \textbf{HTTP Response:} The server sends the generated code back to the user within an HTTP response. \textbf{This code is formatted as a set of C++ functions and definitions intended for integration into the IOPT-Tools-generated \texttt{net\_io.c} file.}
\end{enumerate}

\begin{figure}[h!]
    \centering
    % In your actual document, you would use \includegraphics{path/to/your/diagram.png}
    % The tag below is a placeholder to represent the visual diagram.
    
    \caption{The architectural workflow of the code generation API, from user request to the generated code response.(mudar)}
    \label{fig:api_workflow}
\end{figure}


The tool is implemented as a server-side web Application Programming Interface (API). This architecture decouples the code generation logic from the end-user's local environment, providing a platform-independent and highly accessible solution. The core of the system is a single PHP script, \texttt{gals.php}, which resides on a web server and is responsible for processing all incoming requests\footnote{The complete open-source implementation of the API is publicly available in a Git repository at: \url{git-link-ver-depois}}.

% ===================================================================
% Section 3.2   -----------
% ===================================================================

\section{Design Rationale}
\label{sec:design_rationale}

A Web API was chosen over a standalone desktop application or a command-line tool primarily for its inherent **platform independence** and **accessibility**. This approach eliminates the need for users to install any specialized software; the tool can be accessed from any device with a web browser or a standard HTTP client. This aligns with the web-based nature of the IOPT-Tools environment itself.

The choice of PHP as the implementation language for the proposed tool was motivated by several considerations. First, PHP is inherently designed as a server-side scripting language, well suited for handling web requests and generating dynamic content, which constitutes the core functionality of the tool. Second, since code generation is fundamentally a text manipulation task, the extensive library of built-in string processing functions of PHP greatly facilitated the development of the code templating engine. Third, PHP remains one of the most widely deployed back-end languages, with near-universal support across web hosting providers, thereby ensuring that the tool is both easily deployable and maintainable. Finally, the decision aligns strategically with the IOPT-Tools ecosystem, which itself is structured as a comprehensive web-based development environment. The adoption of a prominent server-side technology such as PHP thus maximizes architectural compatibility and establishes a clear path toward seamless integration of the code generation tool into the main IOPT-Tools web interface.

Although modern APIs often employ POST requests with JSON payloads, a simpler GET-based interface was selected for this application, as it offers several advantages particularly suited to the intended use case. First, GET requests can be constructed and tested directly in a web browser's address bar, greatly facilitating debugging, demonstration, and user adoption; this approach is explicitly supported through the tool’s dedicated help page (\texttt{help.php}). Second, since each code generation request represents an independent and self-contained transaction, the stateless nature of GET requests provides a natural fit, eliminating the need to maintain server-side session state between consecutive requests. Finally, a complete API call, including all its parameters, is encapsulated within a single URL. This feature enhances usability by allowing users to easily save, bookmark, and share specific code generation configurations.



% -------------------------------------------------------------------
% Subsection 3.3 :  ----------- Mapping Model Constructs to Implementation Primitives
% -------------------------------------------------------------------

\section{Mapping Model Constructs to Implementation Primitives}
\label{sec:mapping_constructs}

A critical function of the generation tool is to create a conceptual bridge between the abstract formalism of the decomposed \gls{iopt} Petri net model and concrete primitives of the generated C++ code. This section describes how the API systematically translated the high-level constructs of the GALS-extended \gls{iopt} models into tangible programming constructs.

An important mapping concerns event-triggered transitions, which correspond to protocol-specific message transmissions. In the decomposed model, a transition that sends an event to another sub-model is implemented as a conditional block within the sender's \texttt{PutOutputSignals()} or \texttt{OutputSignals()} function. The activation of this transition, represented in code as \texttt{if (events->eventName == 1)}, is directly associated with a function call that transmits a message using the chosen protocol primitive. Examples include \texttt{Wire.write()} for I²C, \texttt{MySerial.println()} for UART, and \texttt{client.publish()} for MQTT.

Another essential mapping involves the Asynchronous Channel (AC), which in the abstract model facilitates communication across different clock domains in a GALS system. In software, this construct is realized through a two-part mechanism. First, an asynchronous reception primitive is used and its form depends on the chosen protocol: an Interrupt Service Routine (\texttt{onReceive}) for I²C, polling of the serial buffer (\texttt{MySerial.available()}) for UART, or a client callback function for MQTT. Second, upon receiving the correct message, this mechanism sets a \texttt{volatile} boolean flag. The flag functions as a safe, memory-mapped bridge between the asynchronous communication domain (where the message arrives) and the synchronous Petri net execution domain, where it is polled within the \texttt{GetInputSignals()} function.

Finally, the transfer of tokens between sub-models is directly mapped to the exchange of message payloads. Concretely, the data or state represented by a token is encoded in the \texttt{slaveMessage}, \texttt{uartMessage}, or \texttt{tcpMessage} parameter of the API. The successful reception of this specific payload by the destination controller effectively completes the token transfer and enables the progression of the corresponding Petri net.

Through these mappings, the tool establishes a systematic and consistent correspondence between abstract model constructs and concrete implementation primitives, thereby ensuring that the semantics of GALS extended \gls{iopt} models are faithfully preserved in the generated code.


% ===================================================================
% Section 3.3: 
% ===================================================================

\section{Application Programming Interface (API) Specification}
\label{sec:api_spec}

This section provides a formal specification of the Application Programming Interface (API) for the code generation tool. The API is designed to be accessed via HTTP GET requests, with all configuration options passed as URL parameters.

The base endpoint for the API corresponds to the server location of the main script, as illustrated below:
\begin{verbatim}
    http://<server_address>/gals.php
\end{verbatim}

Every API request must include three global parameters that define the context for the code generation. These are detailed in Table \ref{tab:global_params}.

\begin{table}[h!]
    \centering
    \caption{Global API Parameters}
    \label{tab:global_params}
    \begin{tabular}{|l|c|p{9cm}|}
        \hline
        \textbf{Parameter} & \textbf{Status} & \textbf{Description} \\ \hline
        \texttt{protocol} & Mandatory & Specifies the communication protocol. Must be one of: \texttt{i2c}, \texttt{uart}, or \texttt{tcp}. \\ \hline
        \texttt{projectName} & Mandatory & A C-identifier compliant string defining the project name, used for function naming in the generated code. \\ \hline
        \texttt{eventName} & Mandatory & A C-identifier compliant string defining the specific event to be handled. \\ \hline
    \end{tabular}
\end{table}

% -------------------------------------------------------------------
% Subsection for each protocol
% -------------------------------------------------------------------
\subsection{Protocol-Specific Parameters}
\label{subsec:protocol_params}

In addition to the global parameters, each protocol requires or accepts a unique set of parameters to configure its behavior according to the protocol needs.

\paragraph{I²C Protocol.} For I²C communication, the parameters specified in Table \ref{tab:i2c_params} are required.

\begin{table}[h!]
    \centering
    \caption{API Parameters for the I²C Protocol}
    \label{tab:i2c_params}
    \begin{tabular}{|l|c|l|p{6cm}|}
        \hline
        \textbf{Parameter} & \textbf{Status} & \textbf{Type} & \textbf{Description} \\ \hline
        \texttt{slaveAddress} & Mandatory & Integer & The 7-bit address of the slave device. Valid range: 8–119. \\ \hline
        \texttt{slaveMessage} & Mandatory & Char / Int & The command byte, which may be specified either as a single ASCII character or as an integer value (0–127). \\ \hline
    \end{tabular}
\end{table}

\paragraph{UART Protocol.} The UART protocol interface offers several optional parameters for fine-tuning the serial communication, as detailed in Table \ref{tab:uart_params}.

\begin{table}[h!]
    \centering
    \caption{API Parameters for the UART Protocol}
    \label{tab:uart_params}
    \begin{tabular}{|l|c|l|p{6cm}|}
        \hline
        \textbf{Parameter} & \textbf{Status} & \textbf{Type} & \textbf{Description / Default Value} \\ \hline
        \texttt{serialPort} & Optional & Integer & The hardware serial port to use on the ESP32 (0, 1, or 2). \textbf{Default: 2}. \\ \hline
        \texttt{rxPin} & Optional & Integer & The GPIO pin number for receiving data (RX). \textbf{Default: 16}. \\ \hline
        \texttt{txPin} & Optional & Integer & The GPIO pin number for transmitting data (TX). \textbf{Default: 17}. \\ \hline
        \texttt{baudRate} & Optional & Integer & The data transmission rate in bits per second. \textbf{Default: 115200}. \\ \hline
        \texttt{uartMessage} & Optional & String & The message string that triggers the event. \textbf{Default: "trigger\_<eventName>"}. \\ \hline
    \end{tabular}
\end{table}

\paragraph{TCP/MQTT Protocol.} For network communication via TCP/MQTT, the API requires a topic to be specified. Other parameters related to network and broker configuration are optional, with predefined default values that facilitate rapid prototyping and testing. These are listed in Table \ref{tab:tcp_params}.

\begin{table}[h!]
    \centering
    \caption{API Parameters for the TCP/MQTT Protocol}
    \label{tab:tcp_params}
    \begin{tabular}{|l|c|l|p{6cm}|}
        \hline
        \textbf{Parameter} & \textbf{Status} & \textbf{Type} & \textbf{Description / Default Value} \\ \hline
        \texttt{topic} & Mandatory & String & The MQTT topic for publishing and subscribing. \\ \hline
        \texttt{clientID} & Optional & String & The unique client identifier for the MQTT connection. \textbf{Default: "ESP32\_IOPT"}. \\ \hline
        \texttt{broker} & Optional & String & The address of the MQTT broker. \textbf{Default: "broker.hivemq.com"}. \\ \hline
        \texttt{port} & Optional & Integer & The network port for the MQTT broker. \textbf{Default: 1883}. \\ \hline
        \texttt{ssid} & Optional & String & The Service Set Identifier (SSID) of the Wi-Fi network. \textbf{Default: "yourNetworkName"}. \\ \hline
        \texttt{password} & Optional & String & The password for the Wi-Fi network. \textbf{Default: "yourNetworkPassword"}. \\ \hline
        \texttt{tcpMessage} & Optional & String & The message payload that triggers the event. \textbf{Default: "trigger\_<eventName>"}. \\ \hline
    \end{tabular}
\end{table}



% ===================================================================
% Section 3.4: 
% ===================================================================
\section{Analysis of Generated Code}
\label{sec:code_analysis}

This section presents and analyzes the concrete C++ source code produced by the implemented API. \textbf{Crucially, the generated code is specifically designed to be inserted into the \texttt{net\_io.c} file, a standard output of the IOPT-Tools C code generator that serves as the hardware interface layer for the Petri net logic.} For each of the three supported protocols, a sample API call is provided, followed by an analysis of the generated code's structure and key features. The full, verbatim source code for each example is available in the appendices for complete reference.

% -------------------------------------------------------------------
% Subsection 3.4.1: I2C Protocol
% -------------------------------------------------------------------
\subsection{I²C-Based Communication Channel}
\label{subsec:i2c_analysis}

The I²C protocol is well-suited for communication on a shared bus, following a master-slave paradigm. The API generates code for both master and slave controllers to facilitate this model.

To generate the code for a project named `DemoProject` handling an event named `buttonPress`, the following API call is made:
\begin{verbatim}
?protocol=i2c&projectName=DemoProject&eventName=buttonPress&
slaveAddress=9&slaveMessage=P
\end{verbatim}

The complete C++ source code generated by the API call is provided in \textbf{Appendix \ref{appendix:i2c}}.

A key feature of the slave controller's implementation is the safe handling of asynchronous events. To communicate an event from the hardware-triggered Interrupt Service Routine (ISR) to the main synchronous execution loop, a \texttt{volatile} boolean flag is employed. This critical design pattern, which prevents compiler optimizations that could lead to race conditions, is illustrated in the following snippet:

\begin{verbatim}
// Snippet from Slave Controller Code 

// PART 1: Defined in the global scope
volatile bool buttonPress_trigger_flag = 0;

// ...

// PART 3: Polled within the synchronous DemoProject_GetInputSignals()
if (buttonPress_trigger_flag == 1) {
    events->buttonPress = 1;
    buttonPress_trigger_flag = 0; // Reset the flag after processing
}
\end{verbatim}
This pattern ensures that the event is processed reliably and decouples the asynchronous hardware interrupt from the synchronous Petri net execution cycle. The master controller code is more straightforward, with a dedicated function that encapsulates the I²C write operation (see Appendix \ref{appendix:i2c} for the complete listing).

% -------------------------------------------------------------------
% Subsection 3.4.2: UART Protocol
% -------------------------------------------------------------------
\subsection{UART-Based Communication Channel}
\label{subsec:uart_analysis}
UART communication is ideal for point-to-point serial data exchange and does not rely on a shared clock. The generated code supports bidirectional communication between two peer controllers.

\paragraph{Sample API Call.}
\begin{verbatim}
?protocol=uart&projectName=SystemA&eventName=toggleLED&baudRate=9600
\end{verbatim}

The complete source code generated for this UART example can be found in \textbf{Appendix \ref{appendix:uart}}.

The implementation creates a \texttt{HardwareSerial} object for communication, preserving the primary serial port for debugging [cite: 594-596]. The code is symmetric, providing functions for sending and receiving data. Reception is handled by polling the serial buffer. When a valid message is received, its content is compared against a predefined constant. A match sets a \texttt{volatile} flag to signal the event to the synchronous \texttt{SystemA\_GetInputSignals()} function, effectively decoupling the asynchronous serial input from the model execution.

% -------------------------------------------------------------------
% Subsection 3.4.3: TCP/MQTT Protocol
% -------------------------------------------------------------------
\subsection{TCP/MQTT-Based Communication Channel}
\label{subsec:tcp_analysis}
For networked systems, the tool generates code utilizing the MQTT protocol over TCP/IP. This enables a robust publish-subscribe communication model managed by a central broker.

\paragraph{Sample API Call.}
\begin{verbatim}
?protocol=tcp&projectName=SensorNetwork&eventName=alert&
topic=sensors/events
\end{verbatim}

The complete listing of the generated code for this TCP/MQTT example is available in \textbf{Appendix \ref{appendix:tcp}}.

The code leverages the \texttt{PubSubClient.h} library to manage the MQTT connection [cite: 653]. The logic is centered around a \texttt{callback} function, which is triggered by the library upon receiving a message on a subscribed topic [cite: 677-678, 682]. Inside the callback, the message payload is compared to an expected event string. A match sets a \texttt{volatile} flag for the synchronous \texttt{SensorNetwork\_GetInputSignals()} function. The code also includes a \texttt{reconnect} function to automatically re-establish the connection to the broker if it is lost, enhancing the system's resilience.



% ===================================================================
% Section 3.5: 
% ===================================================================
\section{Tool Validation}
\label{sec:validation}

Following the implementation of the code generation tool, a two-stage validation process was conducted to verify its reliability and functional correctness of its output. The first stage focused on testing the API's behavior, while the second stage involved empirically validating the generated C++ code on target hardware.

% -------------------------------------------------------------------
% Subsection 3.5.1: API Functionality Testing
% -------------------------------------------------------------------
\subsection{API Functionality Testing}
\label{subsec:api_testing}

The API endpoint was systematically tested to ensure its robustness and adherence to the specification described in Section 3.3. The testing methodology involved subjecting the API to a series of HTTP GET requests with valid and invalid parameter sets.

The API was tested with a range of valid parameter combinations for the three supported protocols (I²C, UART, and TCP/MQTT). These tests confirmed that the tool consistently produced syntactically correct C++ code that matched the expected output for the given inputs.

To verify the error handling capabilities of the tool, a series of negative tests were performed. These included:
\begin{itemize}
    \item Submitting requests with missing mandatory parameters (for example, omitting the \texttt{topic} for the TCP protocol).
    \item Providing values outside the specified valid range (for example, an I2C \texttt{slaveAddress} of 150).
    \item Using an unsupported protocol name in the \texttt{protocol} parameter.
\end{itemize}
In all such cases, the API correctly identified the input as invalid and returned the expected \texttt{HTTP 400} status code along with a descriptive error message, as designed. This confirmed the robustness of the input validation and error handling logic.

% -------------------------------------------------------------------
% Subsection 3.5.2: Generated Code Validation
% -------------------------------------------------------------------
\subsection{Generated Code Validation}
\label{subsec:code_validation}

The second stage of validation focused on confirming that the code generated by the tool was not only syntactically correct, but also functionally operational. For this purpose, a physical testbed consisting of two ESP32 micro-controller development boards was established for this purpose.

For each of the three protocols, the following procedure was executed:
\begin{enumerate}
    \item A sample API call was made to generate the code for both the sending (Master/Publisher) and receiving (Slave/Subscriber) controllers.
    \item The respective generated C++ code was integrated into a minimal Arduino project, compiled, and uploaded to the two ESP32 boards.
    \item The boards were connected according to the requirements of the protocol being tested (for example, via I2C bus lines, cross-wired UART pins, or connected to the same Wi-Fi network for MQTT).
    \item The sending device was triggered to activate the Petri net output event, and the receiving device's serial monitor was observed for confirmation of message reception.
\end{enumerate}

The empirical tests were successful for all three communication protocols. In each test case, the receiving device correctly registered the event triggered by the sending device. This validation process confirmed that the API generates functionally correct, reliable, and deployable communication modules that successfully implement the behavior specified in the IOPT model.


