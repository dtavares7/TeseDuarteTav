%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter4.tex
%% NOVA thesis document file
%%
%% Chapter with a short latex tutorial and examples
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter4.tex}%


\chapter{Case Study and Performance Analysis}
\label{cha:case_study}


% ===================================================================
%
% Section : Introduction
% ===================================================================

\section{Introduction}
\label{sec:case_study_intro}
isto pa \cite{tavaresgomes2026}


Having detailed the design and implementation of the automated code generation tool in Chapter \ref{cha:chap_3}, this chapter now seeks to validate its practical utility and analyze its output in a real-world scenario. Although the previous chapter verified the tool's functionality, this chapter demonstrates its application within the intended model-driven development workflow, from a high-level system specification to a deployed multi-controller system [cite: 1, 2, 3].

To achieve this, a case study is presented centered on a distributed controller for a three-conveyor automation system [cite: 3]. This application was chosen because it represents a common class of problems in industrial automation, involving multiple coordinated subsystems. The implementation of this case study serves two primary objectives, directly adapted from the research goals presented in [cite: 3]:

\begin{enumerate}
    \item \textbf{To validate the end-to-end development workflow:} This involves demonstrating how the IOPT-Tools framework and the newly developed API are jointly employed to support low-code development of a distributed system. The process begins with a global IOPT model, proceeds through model decomposition, and culminates in the automatic generation and integration of both the controller logic and heterogeneous communication modules [cite: 3].
    
    \item \textbf{To conduct a quantitative performance analysis:} By implementing intercontroller communication using three distinct protocols, I2C, UART, and TCP/MQTT. This chapter provides an empirical comparison of their respective resource overheads. ]The analysis focuses specifically on the memory footprint, offering valuable insight into the trade-offs associated with each protocol in a resource-constrained embedded environment [cite: 3].
\end{enumerate}

This chapter begins by describing the conveyor system use case and its corresponding IOPT model. Then it details the implementation process, showing how the automated tool was used to generate the necessary communication code. Subsequently, the results of the performance analysis are presented and discussed. The chapter concludes with a summary of the key findings of the case study.


% = =================================================================
% Use Case Description
% ===================================================================
\section{Use Case Description: The Three-Conveyor System}
\label{sec:use_case_description}

To demonstrate the practical application of the development workflow, a case study from the industrial automation domain was selected. The system under consideration is a controller for a three-conveyor belt set-up, designed to transport items sequentially from an entrance point to an exit point.

As illustrated in Figure \ref{fig:conveyor_layout}, the physical system consists of three different conveyors. Each conveyor is equipped with two sensors to detect the presence of an item: one at its entrance (\texttt{in1}, \texttt{in2}, \texttt{in3}) and one at its exit (\texttt{out1}, \texttt{out2}, \texttt{out3}). An additional sensor (\texttt{in4}) detects when an item is removed from the end of the final conveyor. Control actions involve activating the motor for each of the three conveyors (\texttt{move1}, \texttt{move2}, \texttt{move3}). The objective of the controller is to ensure that the items move smoothly throughout the system, and each conveyor is activated only when an item is ready to be transferred and the subsequent conveyor is clear.

\begin{figure}[htb]
    \centering
    \includegraphics[width=0.6\columnwidth]{Chapters/Figures/layout.png}
    \caption{Layout of the three-conveyor system, showing the placement of sensors and the direction of item flow, adapted from \cite{tavaresgomes2026}.}
    \label{fig:conveyor_layout}
\end{figure}

The complete centralized behavior of the controller is formally specified using the single global IOPT Petri net model shown in Figure \ref{fig:global_model}. For clarity and brevity in this case study, the model assumes that each conveyor has a capacity of a single item. This global model represents the entire system logic before any consideration of a distributed implementation.

\begin{figure}[htb]
    \centering
    \includegraphics[width=0.95\columnwidth]{Chapters/Figures/modeloglobalcomcuttingset.png}
    \caption{The global IOPT Petri net model specifying the centralized controller for the entire conveyor system. The nodes highlighted in red represent the chosen cutting set for decomposition, adapted from \cite{tavaresgomes2026}.}
    \label{fig:global_model}
\end{figure}

For deployment onto a set of distributed hardware controllers, the global model was decomposed using the net splitting operation available in IOPT-Tools. A cutting set, consisting of three places and three transitions (highlighted in red in Figure \ref{fig:global_model}), was selected to partition the model along the physical boundaries of the three conveyors. The result of this operation is shown in Figure \ref{fig:decomposed_model}. The original centralized model is transformed into a set of four interconnected, concurrent sub-models, each responsible for a portion of the system (Entrance, Conveyor Two, Conveyor Three, and Exit). The connections between these submodels represent the abstract communication channels that must be implemented to ensure the correct synchronized behavior of the distributed system.

\begin{figure*}[htb]
    \centering
    \includegraphics[width=0.9\textwidth]{Chapters/Figures/controller_decomposition.png}
\caption{The transformation from the centralized controller model (left) to a set of concurrent, networked sub-models (right) resulting from the net splitting operation, adapted from \cite{tavaresgomes2026}.}
    \label{fig:decomposed_model}
\end{figure*}


% ===================================================================
% Section 4.3: Implementation via Automated Code Generation
% ===================================================================
\section{Implementation via Automated Code Generation}
\label{sec:use_case_implementation}

With the global IOPT model decomposed into a set of concurrent sub-models (as shown in Figure \ref{fig:decomposed_model}), the next step in the development workflow is to implement the abstract communication channels between them. This task was accomplished using the automated code generation API detailed in Chapter 3.

The target deployment architecture for this case study, shown in Figure \ref{fig:deployment_layout}, employs a heterogeneous mix of three different communication protocols to connect the four controller modules. The following subsections detail how the specific code for each communication link was generated using the API.

\begin{figure*}[htb]
    \centering
    \includegraphics[width=1\textwidth]{Chapters/Figures/prototypelayout.png}
\caption{The heterogeneous deployment architecture for the distributed conveyor system controller, utilizing I²C, UART, and MQTT over TCP/IP for inter-controller communication and synchronization, adapted from \cite{tavaresgomes2026}.}
    \label{fig:deployment_layout}
\end{figure*}


% ===================================================================
% Revised Subsection 4.3.1 with Integrated Validation
% ===================================================================
\subsection{I²C Bus Implementation}
As depicted in the deployment architecture (Figure \ref{fig:deployment_layout}), \textit{Controller Two} acts as the master on a local I²C bus, coordinating with \textit{Controller Entrance} and \textit{Controller Three}, which act as slaves. To generate the necessary master and slave code for an event representing a piece transfer, two API calls similar to the following were used:

\begin{verbatim}
?protocol=i2c&projectName=ControllerTwo&eventName=event37_td_1
&slaveAddress=8&slaveMessage=A
\end{verbatim}

And for the second event:
\begin{verbatim}
?protocol=i2c&projectName=ControllerTwo&eventName=event49_td_3
&slaveAddress=9&slaveMessage=B
\end{verbatim}

To validate the functional behavior of the generated I²C module, the execution of \textit{Controller Two} was captured using the IOPT-Tools simulator. The resulting timing diagram, presented in Figure \ref{fig:timing_diagram_controller2}, provides a detailed view of the controller's operational logic and illustrates the direct correlation between the external I²C communication events and the internal state of the Petri net.  

The behavior can be analyzed by observing the two primary I²C messages:
\begin{itemize}
    \item \textbf{Event \texttt{event37\_td\_1}:} The sequence shows an internal state change, where the marking of a place (e.g., \texttt{p\_11/ppb}) enables the firing of a transition (e.g., \texttt{t\_27/t11}). The diagram confirms that the firing of this transition directly causes the generation of the output signal \texttt{event37\_td\_1}. This corresponds to \textit{Controller Two}, acting as the I²C master, sending a command to one of its slaves (such as \textit{Controller Entrance}).

    \item \textbf{Event \texttt{event49\_td\_3}:} Later in the execution cycle, after the physical process has evolved (indicated by changes in signals like \texttt{outi\_2}), the Petri net reaches a new state. This leads to another transition firing, which in turn causes the generation of the second I²C message, \texttt{event49\_td\_3}. This represents \textit{Controller Two} sending a subsequent command to another slave (such as \textit{Controller Three}).
\end{itemize}

This analysis confirms that the API-generated I²C communication module functions correctly and that the deployed hardware implementation faithfully reproduces the semantics of the original IOPT model.


\begin{figure}[htb!]
    \centering
    \includegraphics[width=\columnwidth]{Chapters/Figures/timing_diagram_controller2.png}
    \caption{Timing diagram for \textit{Controller Two}, showing how internal Petri net states (p\_...) and transition firings (t\_...) lead to the generation of I²C output events (\texttt{event37\_td\_1}, \texttt{event49\_td\_3}).}
    \label{fig:timing_diagram_controller2}
\end{figure}


This complete validation of the I²C module demonstrates the tool's ability to correctly implement the master-slave bus communication as specified by the IOPT model.



% ===================================================================
% UART
% ===================================================================
\subsection{UART Point-to-Point Link}
\label{subsec:uart_implementation}

A direct asynchronous serial link between \textit{Controller Three} and \textit{Controller Exit} was required to signal the final transfer of a piece. The code for this UART-based communication was generated with the following API call:

\begin{verbatim}
?protocol=uart&projectName=ControllerExit
&eventName=event43_td_3&baudRate=115200
\end{verbatim}

To validate the sending side of the UART link, the behavior of \textit{Controller Three} was analyzed using a timing diagram captured by the IOPT-Tools simulator. The diagram, shown in Figure \ref{fig:timing_diagram_controller_three}, details the internal Petri net logic that leads to the transmission of the UART message.

The analysis of the diagram is as follows.
\begin{itemize}
    \item The operational sequence begins with the firing of an internal transition, \textbf{\texttt{t\_29/t1\_31}}, which corresponds to the arrival of the event \texttt{event53\_td\_4}, and then advances the Petri net to a state where it awaits a physical input.
    
    \item The controller remains in this state until the physical sensor input \textbf{\texttt{inii\_3}} is asserted. This external event enables the final transitions in the sequence (\texttt{t\_5\_12/ta\_3} and \texttt{t\_5\_13/tb\_3}).
    
    \item Critically, the firing of these final transitions culminates in the generation of the output signal \textbf{\texttt{event43\_td\_3}}. This represents the moment \textit{Controller Three} transmits the message payload over the UART link to \textit{Controller Exit}.
\end{itemize}

This analysis confirms that the API-generated UART sender code functions as specified. It demonstrates that the controller's internal logic, driven by both its Petri net state and physical inputs, correctly results in the transmission of the serial message at the appropriate time in the operational cycle.

\begin{figure}[htb!]
    \centering
    \includegraphics[width=\columnwidth]{Chapters/Figures/timing_diagram_controller_three.png}
    \caption{Timing diagram for \textit{Controller Exit}, showing how internal state changes and a physical input (\texttt{inii\_3}) lead to the transmission of a UART message (\texttt{event43\_td\_3}).}
    \label{fig:timing_diagram_controller_three}
\end{figure}

% ===================================================================
% MQTT
% ===================================================================
\subsection{TCP/MQTT-Based Communication Channel}
\label{subsec:tcp_implementation}

To handle asynchronous, higher-level status updates between the main controllers, the MQTT protocol was used over a Wi-Fi network. For example, to allow a controller to publish a "Part Arrived" event to a central topic, the following API call was made:

\begin{verbatim}
?protocol=tcp&projectName=ControllerTwo
&eventName=PartArrived&topic=conveyor/status
\end{verbatim}

To validate network-level publisher functionality, the behavior of one of the MQTT-enabled controllers (Controller Three) was analyzed using the IOPT-Tools simulator. The timing diagram, shown in Figure \ref{fig:timing_diagram_tcp}, details how the controller's internal logic, initiated by a generic input event, culminates in the transmission of a message to the MQTT broker.

The analysis of the diagram is as follows.
\begin{itemize}
    \item \textbf{Cycle Trigger:} The operational sequence is initiated by the arrival of an external event from another controller. The reception of this event is represented by the firing of the initial transition, \textbf{\texttt{t\_28/t1\_21}}. This trigger advances the Petri net's state and prepares the controller for its main task.

    \item \textbf{Message Transmission (Publish):} After a sequence of internal state changes that are also dependent on physical inputs (like \textbf{\texttt{inii\_2}}), the Petri net's logic enables the final transition, \textbf{\texttt{t\_4\_13/tb\_2}}. The diagram confirms that the firing of this transition correctly causes the generation of the output signal \textbf{\texttt{event40\_td\_2}}, which represents the controller publishing its message to the specified MQTT topic.
\end{itemize}

This analysis validates that the API-generated TCP/MQTT module's publisher functionality is correctly integrated with the Petri net logic, sending network messages to the broker at the appropriate time based on the controller's state and inputs.

\begin{figure}[htb!]
    \centering
    \includegraphics[width=\columnwidth]{Chapters/Figures/timing_diagram_tcp.png}
    \caption{Timing diagram validating the MQTT publisher. An external input event triggers a Petri net sequence that results in the transmission of an MQTT message (\texttt{event40\_td\_2}).}
    \label{fig:timing_diagram_tcp}
\end{figure}

The successful validation of all three communication modules confirms the tool's ability to reliably implement a complex, heterogeneous communication architecture as specified by the IOPT model.

% ===================================================================
% Section Code Integration
% ===================================================================

\subsection{Code Integration}
For each controller, the baseline logic code was first generated using the standard IOPT-Tools generator, creating a \texttt{net\_io.c} file[cite: 425]. Subsequently, the specific communication modules produced by the API calls were inserted directly into this \texttt{net\_io.c} file, completing the hardware-specific implementation. The entire process of specifying, generating, and integrating the code for all three heterogeneous communication links was completed in a fraction of the time required for manual implementation. This successfully demonstrates the tool's primary objective: to accelerate the development of distributed control systems and reduce the potential for implementation errors by automating the creation of communication infrastructure.
% ===================================================================
% Section 4.4: Performance Analysis and Results
% ===================================================================
\section{Performance Analysis and Results}
\label{sec:performance_analysis}

After successfully implementing the distributed controller for the conveyor system, a performance analysis was performed to quantify the resource overhead associated with the different communication protocols generated by the tool. Although multiple performance metrics such as latency and CPU usage could be considered, this analysis focuses on the **memory footprint**, as it is often the most critical constraint in embedded systems development.

% ===================================================================
% Nova Subsecção para o Setup Experimental no Capítulo 4
% ===================================================================

\subsection{Experimental Setup and Hardware Testbed}
\label{subsec:hardware_setup}

To empirically validate the generated code and conduct the performance analysis, a physical hardware testbed was constructed, representing the distributed controller architecture shown in Figure \ref{fig:deployment_layout}. 

The testbed, photographed in Figure \ref{fig:hardware_photo}, consists of four ESP32-WROOM-32 development boards. These boards were interconnected using a combination of direct wiring and a shared bus on a breadboard to physically realize the I²C and UART communication links. The TCP/MQTT communication was facilitated by the built-in Wi-Fi capabilities of the ESP32s, which allows them to connect to a shared network. This physical prototype served as the basis for all the validation and performance measurements presented in this chapter.

\begin{figure}[htb!]
    \centering
    % Certifique-se de que a sua foto está na pasta de figuras
    \includegraphics[width=0.9\columnwidth]{Chapters/Figures/photo_of_setup.png}
    \caption{The physical hardware testbed for the three-conveyor system, showing the four interconnected ESP32 controller modules.}
    \label{fig:hardware_photo}
\end{figure}

% ===================================================================
% Nova Subsecção Methodology
% ===================================================================
\subsection{Methodology}
\label{subsec:analysis_methodology}

The memory footprint of each of the four controller modules (Entrance, Two, Three and Exit) was measured to determine the overhead of its communication stack. The process was as follows.
\begin{enumerate}
    \item \textbf{Baseline Measurement:} For each controller, the code containing only the Petri net execution logic (generated by the standard IOPT-Tools) was compiled for the ESP32 target. The static program storage space (Flash memory) reported by the compiler was recorded as the baseline.
    \item \textbf{Measurement with Communication:} The API-generated communication code, corresponding to the heterogeneous architecture shown in Figure \ref{fig:deployment_layout}, was integrated with the baseline logic for each controller. The project was then recompiled and the new total program size was recorded.
    \item \textbf{Overhead Calculation:} The communication overhead was calculated as the difference in memory footprint between the baseline measurement and the measurement with the integrated communication code.
\end{enumerate}

\subsection{Results}
\label{subsec:analysis_results}

The results of the memory footprint analysis are summarized in Table \ref{tab:memory_footprint}. The data reveals a significant variation in overhead that is strongly correlated with the complexity of the communication protocols implemented on each controller module.

\begin{table}[htb]
\centering
\small % Reduce the font size for the table
\caption{Memory Analysis of Controller Implementations, adapted from \cite{tavaresgomes2026}.}
\label{tab:memory_footprint}
\sisetup{group-separator={,}}
% Using abbreviated headers to save space
\begin{tabular}{l S[table-format=6.0] S[table-format=6.0] S[table-format=5.0] S[table-format=1.2]}
\toprule
\textbf{Controller ESP} & {\textbf{Baseline}} & {\textbf{W/ Comm.}} & {\textbf{Overhead}} & {\textbf{Overhead}} \\
& {\textbf{(Bytes)}} & {\textbf{(Bytes)}} & {\textbf{(Bytes)}} & {\textbf{(\%)}} \\
\midrule
Entrance & 927970 & 954178 & 26208 & 2.82 \\
Two & 928578 & 955894 & 27316 & 2.94 \\
Three & 928642 & 957014 & 28372 & 3.06 \\
Exit & 927058 & 928478 & 1420  & 0.15 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Discussion of Results}
\label{subsec:analysis_discussion}

The data presented in Table \ref{tab:memory_footprint} clearly illustrate the critical trade-off between functional flexibility and resource consumption when selecting a communication protocol.

The \textbf{Entrance Controller} and \textbf{Controller Two}, both of which implement a full TCP/IP stack for MQTT messaging along with I2C, exhibit the most substantial overheads at approximately 26.2 and 27.3 kB, respectively. This confirms that network-level protocols are the main contributors to the memory footprint. The complexity of the TCP/IP stack, which requires significant buffer space and state management for reliable communication, combined with the MQTT client library, accounts for the vast majority of this resource cost.

This is further corroborated by the data from the \textbf{Exit Controller}. This module, which implements \textit{only} the UART protocol for simple point-to-point asynchronous communication, shows a remarkably low overhead of just 1,420 bytes (a mere 0.15\% increase). This stark contrast highlights the lightweight nature of hardware-level serial protocols compared to their network-level counterparts, as the former can be implemented with minimal software abstraction.

These findings have significant implications for the design of distributed embedded systems. The model-driven development approach, augmented by the tool presented in this thesis, allows a designer to make informed decisions during the system partitioning phase. By analyzing the communication requirements of each sub-model, complex and memory-intensive protocols like TCP/MQTT can be selectively deployed only on controllers that require network connectivity. Simpler nodes can be implemented with lightweight protocols like UART or I2C, thus optimizing the overall system's resource usage and ensuring that hardware constraints are met.



\subsection{Dynamic Behavior Validation}
\label{subsec:dynamic_validation}

Beyond the static analysis of memory consumption, a validation of the system's dynamic behavior was also performed. The integrated simulator within IOPT-Tools was used to capture a timing diagram of \textit{Controller Two}'s execution, enabling a detailed analysis of its operational logic over time.

Figure \ref{fig:timing_diagram_controller2} presents this timing diagram. The diagram illustrates the direct correlation between the internal state of the Petri net (the markings of places, such as \texttt{p\_11/ppb}) and the controller's actions in the physical world (the activation of the \texttt{movei\_2} signal). It is possible to observe, for example, how the arrival of an external communication event (e.g., \texttt{event37\_td\_1}) initiates a sequence of transition firings that alter the net's marking and ultimately result in the activation of a physical output.

This analysis confirms that the C++ code, automatically generated and deployed on the hardware, faithfully preserves the precise operational semantics specified in the original IOPT model.




% ===================================================================
% Section 4.5: Chapter Summary
% ===================================================================
\section{Chapter Summary}
\label{sec:case_study_summary}

This chapter successfully demonstrated the practical application and value of the automated code generation tool through a detailed case study of a three-conveyor distributed control system. The work presented herein validated the entire model-driven development workflow, beginning with a high-level IOPT Petri net model and culminating in a functional, multi-controller hardware implementation. The tool was shown to seamlessly integrate into this workflow, allowing the rapid and reliable implementation of a complex and heterogeneous communication architecture that involves the I2C, UART and TCP / MQTT protocols.

Furthermore, the performance analysis provided critical, quantitative insights into the resource consumption of these protocols. The results empirically confirmed the significant memory overhead of network-level protocols like TCP/MQTT when compared to the lightweight nature of hardware-level protocols such as UART. Ultimately, this case study validates the central proposition of this thesis: that automated generation of communication modules not only accelerates development, but also empowers designers to make informed, data-driven decisions when balancing functional requirements against the hardware constraints of embedded systems.